import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { collaborationClient, ICollaborationClient } from '../../services/collaboration/websocketClient';\nimport { ISessionParticipant, ICursorPosition, ISelectionRange, IContentChange } from '../../services/collaboration/websocketServer';\nimport { ConflictResolutionModal } from './ConflictResolutionModal';\nimport { ParticipantCursors } from './ParticipantCursors';\nimport { CollaborationToolbar } from './CollaborationToolbar';\nimport { v4 as uuidv4 } from 'uuid';\nimport { debounce } from 'lodash';\n\ninterface ICollaborativeEditorProps {\n  sessionId: string;\n  userId: string;\n  resourceType: 'cap_table' | 'shareholders' | 'transactions' | 'share_classes' | 'vesting_schedules';\n  resourceId: string;\n  children: React.ReactNode;\n  onDataChange?: (data: any) => void;\n  readOnly?: boolean;\n}\n\ninterface ICollaborativeEditorState {\n  isConnected: boolean;\n  participants: Map<string, ISessionParticipant>;\n  cursors: Map<string, ICursorPosition>;\n  selections: Map<string, ISelectionRange>;\n  locks: Map<string, { userId: string; userName: string; lockType: string }>;\n  conflicts: Map<string, any>;\n  connectionState: 'connecting' | 'connected' | 'disconnected' | 'error';\n}\n\nexport const CollaborativeEditor: React.FC<ICollaborativeEditorProps> = ({\n  sessionId,\n  userId,\n  resourceType,\n  resourceId,\n  children,\n  onDataChange,\n  readOnly = false\n}) => {\n  const [state, setState] = useState<ICollaborativeEditorState>({\n    isConnected: false,\n    participants: new Map(),\n    cursors: new Map(),\n    selections: new Map(),\n    locks: new Map(),\n    conflicts: new Map(),\n    connectionState: 'disconnected'\n  });\n\n  const [activeConflict, setActiveConflict] = useState<any>(null);\n  const editorRef = useRef<HTMLDivElement>(null);\n  const pendingChanges = useRef<Map<string, IContentChange>>(new Map());\n  const changeBuffer = useRef<IContentChange[]>([]);\n\n  // Debounced function to send batched changes\n  const debouncedSendChanges = useCallback(\n    debounce(() => {\n      const changes = [...changeBuffer.current];\n      changeBuffer.current = [];\n      \n      changes.forEach(change => {\n        collaborationClient.sendContentChange(change);\n      });\n    }, 300),\n    []\n  );\n\n  // Initialize collaboration client\n  useEffect(() => {\n    const initializeCollaboration = async () => {\n      try {\n        // Set up event handlers\n        collaborationClient.onConnectionStateChange = (connectionState) => {\n          setState(prev => ({ ...prev, connectionState, isConnected: connectionState === 'connected' }));\n        };\n\n        collaborationClient.onParticipantJoined = (participant) => {\n          setState(prev => ({\n            ...prev,\n            participants: new Map(prev.participants.set(participant.userId, participant))\n          }));\n        };\n\n        collaborationClient.onParticipantLeft = (participantUserId) => {\n          setState(prev => {\n            const newParticipants = new Map(prev.participants);\n            const newCursors = new Map(prev.cursors);\n            const newSelections = new Map(prev.selections);\n            \n            newParticipants.delete(participantUserId);\n            newCursors.delete(participantUserId);\n            newSelections.delete(participantUserId);\n            \n            return {\n              ...prev,\n              participants: newParticipants,\n              cursors: newCursors,\n              selections: newSelections\n            };\n          });\n        };\n\n        collaborationClient.onCursorMove = (participantUserId, position) => {\n          setState(prev => ({\n            ...prev,\n            cursors: new Map(prev.cursors.set(participantUserId, position))\n          }));\n        };\n\n        collaborationClient.onSelectionChange = (participantUserId, selection) => {\n          setState(prev => ({\n            ...prev,\n            selections: new Map(prev.selections.set(participantUserId, selection))\n          }));\n        };\n\n        collaborationClient.onContentChange = (participantUserId, change) => {\n          // Apply remote change to local data\n          handleRemoteContentChange(change);\n        };\n\n        collaborationClient.onFileLock = (elementId, lockedBy, lockType) => {\n          setState(prev => ({\n            ...prev,\n            locks: new Map(prev.locks.set(elementId, { ...lockedBy, lockType }))\n          }));\n        };\n\n        collaborationClient.onFileUnlock = (elementId) => {\n          setState(prev => {\n            const newLocks = new Map(prev.locks);\n            newLocks.delete(elementId);\n            return { ...prev, locks: newLocks };\n          });\n        };\n\n        collaborationClient.onConflictDetected = (conflict) => {\n          setState(prev => ({\n            ...prev,\n            conflicts: new Map(prev.conflicts.set(conflict.conflictId, conflict))\n          }));\n          \n          // Show conflict resolution modal for the first unresolved conflict\n          if (!activeConflict) {\n            setActiveConflict(conflict);\n          }\n        };\n\n        collaborationClient.onConflictResolved = (conflictId) => {\n          setState(prev => {\n            const newConflicts = new Map(prev.conflicts);\n            newConflicts.delete(conflictId);\n            return { ...prev, conflicts: newConflicts };\n          });\n          \n          if (activeConflict?.conflictId === conflictId) {\n            setActiveConflict(null);\n            \n            // Show next conflict if any\n            const remainingConflicts = Array.from(state.conflicts.values());\n            if (remainingConflicts.length > 0) {\n              setActiveConflict(remainingConflicts[0]);\n            }\n          }\n        };\n\n        collaborationClient.onUserStatusChange = (participantUserId, status) => {\n          setState(prev => {\n            const participant = prev.participants.get(participantUserId);\n            if (participant) {\n              participant.status = status as any;\n              return {\n                ...prev,\n                participants: new Map(prev.participants.set(participantUserId, participant))\n              };\n            }\n            return prev;\n          });\n        };\n\n        // Connect to session\n        await collaborationClient.connect(sessionId, userId);\n        \n      } catch (error) {\n        console.error('Failed to initialize collaboration:', error);\n      }\n    };\n\n    initializeCollaboration();\n\n    // Cleanup on unmount\n    return () => {\n      collaborationClient.disconnect();\n    };\n  }, [sessionId, userId]);\n\n  // Handle mouse movements for cursor tracking\n  useEffect(() => {\n    const handleMouseMove = (event: MouseEvent) => {\n      if (!state.isConnected || !editorRef.current) return;\n\n      const rect = editorRef.current.getBoundingClientRect();\n      const position: ICursorPosition = {\n        x: event.clientX - rect.left,\n        y: event.clientY - rect.top,\n        elementId: (event.target as Element)?.id\n      };\n\n      collaborationClient.sendCursorMove(position);\n    };\n\n    const handleMouseLeave = () => {\n      if (state.isConnected) {\n        collaborationClient.sendCursorMove({ x: -1, y: -1 }); // Hide cursor\n      }\n    };\n\n    const element = editorRef.current;\n    if (element) {\n      element.addEventListener('mousemove', handleMouseMove);\n      element.addEventListener('mouseleave', handleMouseLeave);\n\n      return () => {\n        element.removeEventListener('mousemove', handleMouseMove);\n        element.removeEventListener('mouseleave', handleMouseLeave);\n      };\n    }\n  }, [state.isConnected]);\n\n  // Handle text selection for selection tracking\n  useEffect(() => {\n    const handleSelectionChange = () => {\n      if (!state.isConnected) return;\n\n      const selection = window.getSelection();\n      if (!selection || selection.rangeCount === 0) return;\n\n      const range = selection.getRangeAt(0);\n      const selectionData: ISelectionRange = {\n        startRow: 0, // This would need to be calculated based on your data structure\n        endRow: 0,\n        startCol: 0,\n        endCol: 0,\n        elementId: (range.commonAncestorContainer as Element)?.id\n      };\n\n      collaborationClient.sendSelectionChange(selectionData);\n    };\n\n    document.addEventListener('selectionchange', handleSelectionChange);\n\n    return () => {\n      document.removeEventListener('selectionchange', handleSelectionChange);\n    };\n  }, [state.isConnected]);\n\n  // Handle user activity status\n  useEffect(() => {\n    let idleTimer: NodeJS.Timeout;\n    let awayTimer: NodeJS.Timeout;\n\n    const resetTimers = () => {\n      clearTimeout(idleTimer);\n      clearTimeout(awayTimer);\n\n      if (state.isConnected) {\n        collaborationClient.sendUserStatus('active');\n\n        idleTimer = setTimeout(() => {\n          collaborationClient.sendUserStatus('idle');\n        }, 2 * 60 * 1000); // 2 minutes\n\n        awayTimer = setTimeout(() => {\n          collaborationClient.sendUserStatus('away');\n        }, 10 * 60 * 1000); // 10 minutes\n      }\n    };\n\n    const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'];\n    events.forEach(event => {\n      document.addEventListener(event, resetTimers, true);\n    });\n\n    resetTimers();\n\n    return () => {\n      events.forEach(event => {\n        document.removeEventListener(event, resetTimers, true);\n      });\n      clearTimeout(idleTimer);\n      clearTimeout(awayTimer);\n    };\n  }, [state.isConnected]);\n\n  const handleLocalContentChange = (elementId: string, field: string, oldValue: any, newValue: any) => {\n    if (readOnly || !state.isConnected) return;\n\n    const change: IContentChange = {\n      changeId: uuidv4(),\n      elementId,\n      field,\n      oldValue,\n      newValue,\n      changeType: 'update'\n    };\n\n    // Add to pending changes\n    pendingChanges.current.set(`${elementId}:${field}`, change);\n    changeBuffer.current.push(change);\n\n    // Send changes after debounce\n    debouncedSendChanges();\n\n    // Notify parent component\n    onDataChange?.(newValue);\n  };\n\n  const handleRemoteContentChange = (change: IContentChange) => {\n    // Remove from pending if it matches a local change\n    const pendingKey = `${change.elementId}:${change.field}`;\n    const pendingChange = pendingChanges.current.get(pendingKey);\n    \n    if (pendingChange && pendingChange.newValue === change.newValue) {\n      pendingChanges.current.delete(pendingKey);\n      return; // This is our own change, ignore it\n    }\n\n    // Apply remote change to UI\n    onDataChange?.(change.newValue);\n  };\n\n  const handleConflictResolution = (conflictId: string, selectedValue: any) => {\n    collaborationClient.resolveConflict(conflictId, selectedValue);\n    setActiveConflict(null);\n    \n    // Show next conflict if any\n    const remainingConflicts = Array.from(state.conflicts.values())\n      .filter(c => c.conflictId !== conflictId);\n    \n    if (remainingConflicts.length > 0) {\n      setActiveConflict(remainingConflicts[0]);\n    }\n  };\n\n  const lockElement = (elementId: string, lockType: string = 'edit') => {\n    if (state.isConnected) {\n      collaborationClient.sendFileLock(elementId, lockType);\n    }\n  };\n\n  const unlockElement = (elementId: string) => {\n    if (state.isConnected) {\n      collaborationClient.sendFileUnlock(elementId);\n    }\n  };\n\n  const isElementLocked = (elementId: string): boolean => {\n    const lock = state.locks.get(elementId);\n    return lock ? lock.userId !== userId : false;\n  };\n\n  const getElementLockOwner = (elementId: string) => {\n    return state.locks.get(elementId);\n  };\n\n  return (\n    <div className=\"relative\">\n      {/* Collaboration Toolbar */}\n      <CollaborationToolbar\n        isConnected={state.isConnected}\n        connectionState={state.connectionState}\n        participants={Array.from(state.participants.values())}\n        conflictCount={state.conflicts.size}\n      />\n\n      {/* Main Editor Area */}\n      <div\n        ref={editorRef}\n        className=\"relative\"\n        data-collaboration-session={sessionId}\n      >\n        {/* Participant Cursors Overlay */}\n        {state.isConnected && (\n          <ParticipantCursors\n            cursors={state.cursors}\n            selections={state.selections}\n            participants={state.participants}\n            currentUserId={userId}\n          />\n        )}\n\n        {/* Content with collaboration context */}\n        <div className=\"collaborative-content\">\n          {React.cloneElement(children as React.ReactElement, {\n            onContentChange: handleLocalContentChange,\n            lockElement,\n            unlockElement,\n            isElementLocked,\n            getElementLockOwner,\n            readOnly: readOnly || !state.isConnected\n          })}\n        </div>\n\n        {/* Connection Status Indicator */}\n        {!state.isConnected && (\n          <div className=\"absolute top-2 right-2 bg-yellow-100 border border-yellow-400 text-yellow-800 px-3 py-1 rounded-md text-sm\">\n            <div className=\"flex items-center space-x-2\">\n              {state.connectionState === 'connecting' && (\n                <>\n                  <div className=\"animate-spin rounded-full h-3 w-3 border-b-2 border-yellow-600\"></div>\n                  <span>Connecting...</span>\n                </>\n              )}\n              {state.connectionState === 'error' && (\n                <>\n                  <div className=\"w-3 h-3 bg-red-500 rounded-full\"></div>\n                  <span>Connection Error</span>\n                </>\n              )}\n              {state.connectionState === 'disconnected' && (\n                <>\n                  <div className=\"w-3 h-3 bg-gray-500 rounded-full\"></div>\n                  <span>Offline Mode</span>\n                </>\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Conflict Resolution Modal */}\n      {activeConflict && (\n        <ConflictResolutionModal\n          conflict={activeConflict}\n          participants={state.participants}\n          onResolve={handleConflictResolution}\n          onCancel={() => setActiveConflict(null)}\n        />\n      )}\n    </div>\n  );\n};